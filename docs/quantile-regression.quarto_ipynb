{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Quantile Regression\"\n",
        "format:\n",
        "  html:\n",
        "    html-table-processing: none\n",
        "toc: true\n",
        "toc-title: \"On this page\"\n",
        "toc-location: left\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "PyFixest now experimentally supports quantile regression!\n"
      ],
      "id": "89f328e0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "%load_ext autoreload\n",
        "\n",
        "import pyfixest as pf\n",
        "import numpy as np\n",
        "import time\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import itertools, time\n",
        "import matplotlib.pyplot as plt\n",
        "import math\n",
        "\n",
        "data = pf.get_data()"
      ],
      "id": "68bb560b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Basic Example\n",
        "\n",
        "Just as in `statsmodels`, the function that runs a quantile regression is `quantreg()`.\n",
        "\n",
        "Below, we loop over 10 different quantiles.\n"
      ],
      "id": "c8e2e225"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "%%capture\n",
        "fits = [pf.quantreg(\"Y ~ X1 + X2 + f1\", data = data, quantile = q) for q in np.arange(0.1, 1, 0.1)]"
      ],
      "id": "31e1d441",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can inspect the quantile regression results using the dedicated `qplot()` function.\n"
      ],
      "id": "7a2512b2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pf.qplot(fits, nrow = 2)"
      ],
      "id": "19c1b985",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We observe some heterogeneity in the intercept, but all other variants are homogeneous across users.\n",
        "\n",
        "## Solvers\n",
        "\n",
        "By default, `pf.quantreg` uses an interior-point solver as in Koenker and Ng. For big data sets with many observations, it is often sensible to use an interior-point solver with pre-processing (as in Portnoy and Koenker, see Chernozhukov et al for details), which can speed up the estimation time significantly. Because the pre-processing step requires taking a random sample, the method assumes that observations are independent. Additionally, for the purpose of reproducibility, it is advisable to set a seed.\n",
        "\n",
        "You can access the \"preprocessing frisch-newton\" algorithm by setting the `method` argument to `\"pfn\"`:\n"
      ],
      "id": "4f7aa342"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "%%capture\n",
        "fit_fn = pf.quantreg(\n",
        "  fml = \"Y ~ X1\",\n",
        "  method = \"fn\",     # standard frisch newton interior point solver\n",
        "  data = data,\n",
        ")\n",
        "fit_pfn = pf.quantreg(\n",
        "  fml = \"Y ~ X1\",\n",
        "  method = \"pfn\",   # standard frisch newton interior point solver with pre-processing\n",
        "  seed = 92,         # set a seed for reproducibility\n",
        "  data = data,\n",
        ")\n",
        "\n",
        "pf.etable([fit_fn, fit_pfn])"
      ],
      "id": "3595997e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Quantile Regression Process\n",
        "\n",
        "Instead of running multiple independent quantile regression as in the first regression above, the literature on quantile regression has developed multiple algorithms to speed up the \"quantile regression process\". Two such algorithms are described in detail in Chernozhukov, Fernandez-Val and Melly and are implemented in PyFixest. They can be accessed via the `multi_method` argument, and both can significantly speed up estimation time of the full quantile regression process.\n"
      ],
      "id": "50b746d3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fml = \"Y~X1\"\n",
        "method = \"pfn\"\n",
        "seed = 929\n",
        "quantiles = [0.1, 0.5, 0.9]\n",
        "\n",
        "fit_multi1 = pf.quantreg(\n",
        "  fml = fml,\n",
        "  data = data,\n",
        "  method = method,\n",
        "  multi_method = \"cfm1\",\n",
        "  seed = seed,\n",
        "  quantile = quantiles,\n",
        ")\n",
        "\n",
        "fit_multi2 = pf.quantreg(\n",
        "  fml = fml,\n",
        "  data = data,\n",
        "  method = method,\n",
        "  multi_method = \"cfm2\",\n",
        "  seed = seed,\n",
        "  quantile = quantiles\n",
        ")\n",
        "\n",
        "pf.etable(fit_multi1.to_list() +  fit_multi2.to_list())"
      ],
      "id": "42380c24",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that the first method `cfm1` is exactly identical to running separate regressions per quantile, while the second method `cfm2` is only **asymptotically** identical.\n",
        "\n",
        "You can combine different estimation `method`'s with different `multi_methods`:\n"
      ],
      "id": "819550ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fit_multi2a = pf.quantreg(\n",
        "  fml = \"Y~X1\",\n",
        "  data = data,\n",
        "  method = \"fn\",\n",
        "  multi_method = \"cfm1\",\n",
        "  seed = 233,\n",
        "  quantile = [0.25, 0.75]\n",
        ")\n",
        "\n",
        "fit_multi2b = pf.quantreg(\n",
        "  fml = \"Y~X1\",\n",
        "  data = data,\n",
        "  method = \"pfn\",\n",
        "  multi_method = \"cfm1\",\n",
        "  seed = 233,\n",
        "  quantile = [0.25, 0.75]\n",
        ")\n",
        "\n",
        "pf.etable(fit_multi2a.to_list() +  fit_multi2b.to_list())"
      ],
      "id": "da8e5005",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Inference\n",
        "\n",
        "`pf.quantreg` supports heteroskedasticity-robust inference (\"nid\") and cluster robust inference following\n",
        "Parente & Santos Silva. See this [slide set](https://www.stata.com/meeting/uk15/abstracts/materials/uk15_santossilva.pdf)\n",
        "or the [Journal of Econometrics paper](https://repository.essex.ac.uk/8976/1/dp728.pdf) for details.\n"
      ],
      "id": "4d7bcc04"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fit_nid = pf.quantreg(\"Y ~ X1 + X2 + f1\", data = data, quantile = 0.5, vcov = \"nid\")\n",
        "fit_crv = pf.quantreg(\"Y ~ X1 + X2 + f1\", data = data, quantile = 0.5, vcov = {\"CRV1\": \"f1\"})"
      ],
      "id": "a6dea6d5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Performance\n",
        "\n",
        "### Different Solvers\n",
        "\n",
        "Here we benchmark the performance of the solvers accessible via the `method` argument. Tba.\n",
        "\n",
        "### Quantile Regression Process\n",
        "\n",
        "![](../benchmarks/quantreg_benchmark.png)\n",
        "\n",
        "# Literature\n",
        "\n",
        "- Koenker and Ng (2004): A Frisch-Newton Algorithm for Sparse Quantile Regression - [link](http://www.econ.uiuc.edu/~roger/research/sparse/fn3.pdf)\n",
        "- Victor Chernozhukov, Iván Fernández-Val, Blaise Melly (2019): Fast Algorithms for the Quantile Regression Process - [link](https://arxiv.org/abs/1909.05782)\n",
        "- Parente & Santos Silva (2015): Quantile Regression with Clustered Data - [link](https://econpapers.repec.org/article/bpjjecome/v_3a5_3ay_3a2016_3ai_3a1_3ap_3a1-15_3an_3a5.htm)\n",
        "- Portnoy & Koenker (1997): The gaussian hare and the laplacian tortoise: Computability of squared-error versus absolute-error estimators [link](https://experts.illinois.edu/en/publications/the-gaussian-hare-and-the-laplacian-tortoise-computability-of-squ)"
      ],
      "id": "4f3da85e"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}