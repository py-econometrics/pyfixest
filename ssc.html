<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>On Small Sample Corrections</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-831a6e13d34e89ab8943621a9b1bffba.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./pyfixest.html"> 
<span class="menu-text">PyFixest</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./quickstart.html"> 
<span class="menu-text">Quickstart</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./reference/index.html"> 
<span class="menu-text">Function Reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./changelog.html"> 
<span class="menu-text">Changelog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./contributing.html"> 
<span class="menu-text">Contributing</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-learn-more" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Learn more</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-learn-more">    
        <li>
    <a class="dropdown-item" href="./table-layout.html">
 <span class="dropdown-text">Regression Tables and Summary Statistics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./marginaleffects.html">
 <span class="dropdown-text">Hypothesis Testing and Marginal Effects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./difference-in-differences.html">
 <span class="dropdown-text">Difference-in-Differences Estimation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./multiple_testing.html">
 <span class="dropdown-text">Multiple Testing Corrections</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./regression_decomposition.html">
 <span class="dropdown-text">Regression Decomposition</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./ssc.html">
 <span class="dropdown-text">On Small Sample Corrections</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./compare-fixest-pyfixest.html">
 <span class="dropdown-text">Compare fixest &amp; PyFixest</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./pyfixest_gpu.html">
 <span class="dropdown-text">PyFixest on the GPU</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./replicating-the-effect.html">
 <span class="dropdown-text">Replicating ‘The Effect’ with PyFixest</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/py-econometrics/pyfixest/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#small-sample-adjustments" id="toc-small-sample-adjustments" class="nav-link active" data-scroll-target="#small-sample-adjustments">Small Sample Adjustments</a>
  <ul class="collapse">
  <li><a href="#adj-true" id="toc-adj-true" class="nav-link" data-scroll-target="#adj-true"><code>adj = True</code></a></li>
  <li><a href="#fixef_k" id="toc-fixef_k" class="nav-link" data-scroll-target="#fixef_k"><code>fixef_k</code></a>
  <ul class="collapse">
  <li><a href="#fixef_k-none" id="toc-fixef_k-none" class="nav-link" data-scroll-target="#fixef_k-none"><code>fixef_k = "none"</code></a></li>
  <li><a href="#fixef_k-full" id="toc-fixef_k-full" class="nav-link" data-scroll-target="#fixef_k-full"><code>fixef_k = "full"</code></a></li>
  <li><a href="#fixef_k-nested" id="toc-fixef_k-nested" class="nav-link" data-scroll-target="#fixef_k-nested"><code>fixef_k = nested</code></a></li>
  </ul></li>
  <li><a href="#cluster_adj" id="toc-cluster_adj" class="nav-link" data-scroll-target="#cluster_adj"><code>cluster_adj</code></a></li>
  <li><a href="#cluster_df" id="toc-cluster_df" class="nav-link" data-scroll-target="#cluster_df"><code>cluster_df</code></a></li>
  </ul></li>
  <li><a href="#more-on-inference" id="toc-more-on-inference" class="nav-link" data-scroll-target="#more-on-inference">More on Inference</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">On Small Sample Corrections</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The <code>fixest</code> R package offers a myriad of options to control small sample corrections. Despite an excellent <a href="https://cran.r-project.org/web/packages/fixest/vignettes/standard_errors.html">vignette</a> on the topic, I have spent way too much time trying to make <code>pyfixest</code> standard errors with fixest. Before I forget <strong>why</strong> things are implemented the way they are, I though I’d document them here.</p>
<p>In both <code>fixest</code> and <code>pyfixest</code>, small sample corrections can be controlled via the <code>ssc</code> function. In <code>pyfixest</code>, <code>ssc</code> has four function arguments:</p>
<ul>
<li><code>adj</code>: controls if a first ssc adjustment should be applied.</li>
<li><code>fixef_k</code>: controls how to compute the “effective” number of estimated parameters “k”.</li>
<li><code>cluster_adj</code>: controls if a second ssc adjustment should be applied.</li>
<li><code>cluster_df</code>: controls how to compute ssc adjustments in case of multi-way clustering.</li>
</ul>
<p>To compute an adjusted variance covariance formula, the following formula is used:</p>
<p><span class="math display">\[
    vcov_adj = 1(adj, adj_val(N, dof_k(fixef_k)), 1) x 1(cluster_adj, cluster_adj_val(G, cluster_df), 1) x vcov
\]</span></p>
<p>where</p>
<ul>
<li><code>1()</code> denotes an indicator function</li>
<li><code>adj</code> is a boolean that denotes if there is a is a scalar adjustment</li>
<li><code>cluster_df</code> is a boolean that denotes if there is another scalar adjustment</li>
<li><code>dof_k</code> set the number of ‘variables’ used to compute <code>adj</code>.</li>
<li><code>fixef_k</code> controls how <code>dof_k</code> is computed</li>
<li><code>G</code> sets the numebr of unique clusters in the data. In case of heteroskedastic errors, <code>G = N</code>.</li>
<li><code>vcov</code> is the unadjusted variance-covariance matrix.</li>
</ul>
<p>Last, but not part of the formula above, is <code>df_t</code>, which denotes the degrees of freedom used in computing t-statistics needed for pvalues and confidence intervals. We always have that <code>df_t = N - dof_k</code>.</p>
<section id="small-sample-adjustments" class="level1">
<h1>Small Sample Adjustments</h1>
<section id="adj-true" class="level2">
<h2 class="anchored" data-anchor-id="adj-true"><code>adj = True</code></h2>
<p>If <code>adj=True</code>, we multiply the unadjusted variance covariance matrix with</p>
<p><span class="math display">\[
    adj_val = \frac{N-1}{N-dof_k}.
\]</span></p>
<p>If not, no adjustment is made.</p>
</section>
<section id="fixef_k" class="level2">
<h2 class="anchored" data-anchor-id="fixef_k"><code>fixef_k</code></h2>
<p>The value for <code>adj_val</code> depends on <code>dof_k</code>. The <code>fixef_k</code> argument allows us control how <code>dof_k</code> is computed. Three options are supported: <code>fixef_k in ["none", "full", "nested"]</code>.</p>
<section id="fixef_k-none" class="level3">
<h3 class="anchored" data-anchor-id="fixef_k-none"><code>fixef_k = "none"</code></h3>
<p>If <code>fixef_k = "none"</code>, the fixed effects are discarded. For example, if we fit a model <code>Y ~ X1 | f1</code>, we have <code>k = 1</code>, where <code>k</code> denotes the number of covariates that are not specified as fixed effects using two-part formula syntax. For a model <code>Y ~ X1 + X2 | f1</code>, we would set <code>k = 2</code>, etc.</p>
</section>
<section id="fixef_k-full" class="level3">
<h3 class="anchored" data-anchor-id="fixef_k-full"><code>fixef_k = "full"</code></h3>
<p>Here, we add the levels of fixed effects. To avoid multicollinearity, we have to drop one level from each fixed effects whenever we have more than one fixed effects. Hence if <code>n_fe</code> denotes the total number of fixed effects and <code>f_{i}</code> a given fixed effect, we compute <code>dof_k</code> as <code>dof_k = k + k_fe</code>, where <code>k_fe = \sum_{i}^{n_fe} levels(f_i)</code> + (n_fe - 1)<code>if we have more than one fixed effect and</code>k_fe = <em>{i}^{n_fe} levels(f_i) = levels(f</em>{1})` if we have only one fixed effects.</p>
</section>
<section id="fixef_k-nested" class="level3">
<h3 class="anchored" data-anchor-id="fixef_k-nested"><code>fixef_k = nested</code></h3>
<p>If we have <strong>clustered</strong> standard errors, fixed effects might be fully nested within fixed effects. One simple example are <strong>cluster fixed effects</strong>. If we run a model</p>
<pre><code>pf.feols("Y ~ X1 | f1", vcov = {"CRV1":f1})</code></pre>
<p>the fixed effect <code>f1</code> is fully nested in the cluster variable <code>f1</code> because they are identical.</p>
<p>A common example of fixed effects nested within a cluster would be district fixed effects and state level clustering - each district is fully nested in a given state.</p>
<p>If <code>fixef_k</code> is set to <code>"nested"</code>, any “nested” fixed effects are dropped from the computation of <code>k_fe</code>, hence we have</p>
<p><span class="math display">\[
    k_fe =  \sum_{i}^{n_fe} levels(f_i)  - k_fe_nested - (n_fe - 1)
\]</span></p>
<p>where <span class="math inline">\(k_fe_nested\)</span> is the cardinality of the nested fixed effects. For a cluster fixed effect, <code>k_fe_nested = G</code>, where <code>G</code> is the number of clusters.</p>
<p>Note that if you previously subtracted a level from a nested fixed effect, you might have to add it back (I have lost a few hours on figuring this one out).</p>
</section>
</section>
<section id="cluster_adj" class="level2">
<h2 class="anchored" data-anchor-id="cluster_adj"><code>cluster_adj</code></h2>
<p>If <code>cluster_adj = True</code>, another small sample correction is applied:</p>
<p><span class="math display">\[
    cluster_df_val = G / (G - 1)
\]</span></p>
<p>with <span class="math inline">\(G\)</span> the number of clusters in case of clustered standard errors and <code>G = N</code> for heteroskedastic errors. This was a point of great confusion for me - why would the cluster adjustment be applied to heteroskedastic errors too? But it turns out that this is consistent with R’s sandwich package, which is the benchmark implementation for sandwich covariance matrices. One way to think about this: if errors are heteroskedastic, we have “singleton” clusters, hence <span class="math inline">\(G = N\)</span>.</p>
<p>One other point of great confusion for me was that even if <code>cluster_adj = True</code> for “iid” errors, the <code>cluster_val_df</code> is set to <code>1</code>.</p>
</section>
<section id="cluster_df" class="level2">
<h2 class="anchored" data-anchor-id="cluster_df"><code>cluster_df</code></h2>
<p>This is only relevant when we use multi-way clustered standard errors. Recall that we can write two-way clustered errors as</p>
<p><span class="math display">\[
    vcov = ssc_{A} x vcov_{A} + ssc_{B} x vcov_B - ssc_{AB} x vcov_{AB}
\]</span></p>
<p>where <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> denote the clustering variables with <code>G(AB) &gt; G_{A} &gt; G_{B}</code> clusters.</p>
<p>If we set <code>cluster_df = "min"</code>, we compute <code>ssc_{A}</code>, <code>ssc_{B}</code>, <code>ssc_{AB}</code> setting <code>G_{A} = G_{B} = G_{AB} = min(G_{A}, G_{B}, G_{AB})</code>. If we set <code>cluster_df = "conventional</code>, we use <code>G_{A</code> to compute <code>ssc_{A}</code>, <code>G_{B}</code> to compute <code>ssc_{B}</code>, etc.</p>
</section>
</section>
<section id="more-on-inference" class="level1">
<h1>More on Inference</h1>
<p>For computing critical values, we compute degrees of freedom <code>df_t</code> as <code>N - dof_k</code> unless errors are <strong>clustered</strong>, in which case we use <code>G - 1</code>.</p>
<p>To compute critical values for OLS and IV regression, we compute t-statistics using <code>df_t</code> degrees of freedom. For GLMs, we compute critical values based on a normal distribution (z-statistics). See <a href="https://github.com/py-econometrics/pyfixest/blob/864da9c0d1797aff70e3f5b420e4c73f7256642d/pyfixest/estimation/feols_.py#L851">here</a> for the implementation.</p>
<p>For multiway-clustered errors, we set <code>df_t = min(G_1 - 1, G_2 - 1)</code> in case of two-way clustering, <code>df_t = min(G_1 - 1, G_2 - 1, G_3 - 1)</code> in case of three-way clustering (currently not supported), etc.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>